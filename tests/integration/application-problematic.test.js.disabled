/**
 * Simplified Integration Tests for MiniTel Application
 * Focus on core integration scenarios only
 */

const { MockSocket } = require('../mocks/net-mock');

// Mock the net module
jest.mock('net', () => ({
  Socket: MockSocket
}));

const MiniTelApplication = require('../../src/client/application');
const { encodeFrame } = require('../../src/protocol/frame');
const { RESPONSES } = require('../../src/protocol/constants');
const fs = require('fs').promises;
const path = require('path');

describe('MiniTel Application Integration (Simplified)', () => {
  let app;
  let tempRecordingsDir;

  beforeEach(async () => {
    // Create temporary recordings directory
    tempRecordingsDir = path.join(__dirname, '../temp/recordings');
    await fs.mkdir(tempRecordingsDir, { recursive: true });
    
    // Reset console mocks
    console.log = jest.fn();
    console.error = jest.fn();
    console.warn = jest.fn();
  });

  afterEach(async () => {
    if (app) {
      try {
        await app.stop();
      } catch (error) {
        // Ignore errors during cleanup
      }
    }
    
    // Clean up recordings
    try {
      const files = await fs.readdir(tempRecordingsDir);
      await Promise.all(
        files.map(file => fs.unlink(path.join(tempRecordingsDir, file)))
      );
    } catch (error) {
      // Directory might not exist
    }
  });

  describe('Core Integration', () => {
    test('should complete successful protocol sequence', async () => {
      // Simple successful sequence: HELLO_ACK -> DUMP_FAILED -> DUMP_OK
      const responses = [
        encodeFrame(RESPONSES.HELLO_ACK, 1, ''),
        encodeFrame(RESPONSES.DUMP_FAILED, 3, ''),
        encodeFrame(RESPONSES.DUMP_OK, 5, 'SUCCESS_CODE')
      ];

      jest.spyOn(require('net'), 'Socket').mockImplementation(() => {
        return new MockSocket({
          shouldConnect: true,
          connectDelay: 5,
          responseDelay: 10,
          mockResponses: responses
        });
      });

      app = new MiniTelApplication({
        host: 'localhost',
        port: 8080,
        record: false,
        autoReconnect: false
      });

      await app.start();

      // Verify success  
      expect(console.log).toHaveBeenCalledWith('âœ… Application completed successfully');
      expect(console.log).toHaveBeenCalledWith(expect.stringContaining('ðŸŽ¯ Successfully retrieved code with'));
    }, 30000); // 30 second timeout

    test('should handle connection failure gracefully', async () => {
      jest.spyOn(require('net'), 'Socket').mockImplementation(() => {
        return new MockSocket({
          shouldConnect: false
        });
      });

      app = new MiniTelApplication({
        host: 'localhost',
        port: 8080,
        record: false,
        autoReconnect: false,
        maxReconnectAttempts: 1
      });

      await expect(app.start()).rejects.toThrow('Failed to connect after 1 attempts');
    });

    test('should integrate with session recording', async () => {
      const responses = [
        encodeFrame(RESPONSES.HELLO_ACK, 1, ''),
        encodeFrame(RESPONSES.DUMP_OK, 3, 'RECORDED_CODE'),
        encodeFrame(RESPONSES.DUMP_OK, 5, 'ANOTHER_CODE')
      ];

      jest.spyOn(require('net'), 'Socket').mockImplementation(() => {
        return new MockSocket({
          shouldConnect: true,
          connectDelay: 5,
          responseDelay: 10,
          mockResponses: responses
        });
      });

      app = new MiniTelApplication({
        host: 'localhost',
        port: 8080,
        record: true,
        recordingsDir: tempRecordingsDir,
        autoReconnect: false
      });

      await app.start();

      // Verify recording was created
      const recordings = await fs.readdir(tempRecordingsDir);
      expect(recordings.length).toBe(1);

      // Verify recording content
      const recordingFile = path.join(tempRecordingsDir, recordings[0]);
      const recordingData = JSON.parse(await fs.readFile(recordingFile, 'utf8'));
      
      expect(recordingData.metadata.serverHost).toBe('localhost');
      expect(recordingData.metadata.serverPort).toBe(8080);
      expect(recordingData.interactions.length).toBeGreaterThan(0);
    }, 30000); // 30 second timeout
  });
});
